<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <title>purr-data</title>
  <meta name="description" content="test of purr-data compiled for web with emscripten" />
  <meta name="keywords" content="purr-data emscripten" />
  <meta name="generator" content="emsripten" />
  <style>
    button {
      display: block;
      margin-top: 10px;
    }
  </style>
  <script src="webmidi.min.js"></script>
</head>

<body>
  <input id="uploadPatch" type="file" />
  <button id="newPatch">new</button>
  <button id="openPatch">open</button>
  <button id="closePatch">close</button>
  <button id="printPatch">print</button>
  <button id="downloadPatch">download</button>
  <button id="dspOn">dsp on</button>
  <button id="dspOff">dsp off</button>

  <script>
    //--------------------- emscripten ----------------------------
    var Module
      = {
      preRun: []
      , postRun: []
      , print: function (e) {
        1 < arguments.length && (e = Array.prototype.slice.call(arguments).join(" "));
        console.log(e);
      }
      , printErr: function (e) {
        1 < arguments.length && (e = Array.prototype.slice.call(arguments).join(" "));
        console.error(e)
      }
      , pd: {} // make pd object accessible from outside of the scope
      , mainInit: function () { // called after Module is ready
        Module.pd = new Module.Pd(); // instantiate Pd object
        if (typeof Module.pd != "object") {
          console.error("Pd: failed to instantiate pd object");
          Module.mainExit();
          return;
        }
        var pd = Module.pd;
        pd.setNoGui(false); // set to true if you don't use the pd's gui

        // redefine functions here to replace original ones
        pdsend = function () {
          var string = Array.prototype.join.call(arguments, " ");
          var array = string.split(" ");
          pd.startMessage(array.length - 2);
          for (var i = 2; i < array.length; i++) {
            if (isNaN(array[i])) {
              pd.addSymbol(array[i]);
            }
            else {
              pd.addFloat(parseFloat(array[i]));
            }
          }
          pd.finishMessage(array[0], array[1]);
        }

        // create an AudioContext
        var isWebAudioSupported = false;
        var audioContextList = [];
        (function () {
          var AudioContext = self.AudioContext || self.webkitAudioContext || false;
          if (AudioContext) {
            isWebAudioSupported = true;
            self.AudioContext = new Proxy(AudioContext, {
              construct(target, args) {
                var result = new target(...args);
                audioContextList.push(result);
                return result;
              }
            });
          }
        })();
        if (isWebAudioSupported) {
          console.log("Audio: successfully enabled");
        }
        else {
          alert("The Web Audio API is not supported in this browser.");
          console.error("Audio: failed to use the web audio");
          Module.mainExit();
          return;
        }

        // check if the web midi library exists and is supported
        var isWebMidiSupported = false;
        if (typeof WebMidi != "object") {
          console.error("failed to find the 'WebMidi' object");
          Module.mainExit();
          return;
        }

        // array of enabled midi device ids (without duplicates)
        var midiInIds = [];
        var midiOutIds = [];

        // 10 input, 10 output device numbers to send with "pd midi-dialog"
        // 0: no device, 1: first available device, 2: second available device...
        var midiarr = [];

        // enable midi
        WebMidi.enable(function (err) {
          if (err) {
            // if the browser doesn't support web midi, one can still use pd without it
            console.error("Midi: failed to enable midi", err);
          }
          else {
            isWebMidiSupported = true;
            console.log("Midi: successfully enabled");

            // select all available input/output devices as default
            midiInIds = [];
            midiOutIds = [];
            for (var i = 0; i < WebMidi.inputs.length; i++) {
              midiInIds.push(WebMidi.inputs[i].id);
            }
            for (var i = 0; i < WebMidi.outputs.length; i++) {
              midiOutIds.push(WebMidi.outputs[i].id);
            }
            midiarr = [];
            for (var i = 0; i < 10; i++) {
              var devno = i < midiInIds.length ? i + 1 : 0;
              midiarr.push(devno);
            }
            for (var i = 0; i < 10; i++) {
              var devno = i < midiOutIds.length ? i + 1 : 0;
              midiarr.push(devno);
            }
            // called whenever input/output devices connection status changes
            function onConnectionChanged() {
              console.log("Midi: connection status changed");
              pdsend("pd midi-dialog", midiarr.join(" ")); // send message to pd
            }
            // make sure we get only one callback at a time
            var timerId;
            WebMidi.addListener("connected", function (e) {
              clearTimeout(timerId);
              timerId = setTimeout(() => onConnectionChanged(), 100);
            });
            WebMidi.addListener("disconnected", function (e) {
              clearTimeout(timerId);
              timerId = setTimeout(() => onConnectionChanged(), 100);
            });
          }
        }, false); // not use sysex

        // reinit pd (called by "pd audio-dialog" message)
        Module.Pd.reinit = function (newinchan, newoutchan, newrate) {
          if (pd.init(newinchan, newoutchan, newrate, pd.getTicksPerBuffer())) {

            // print obtained settings
            console.log("Pd: successfully reinitialized");
            console.log("Pd: audio input channels: " + pd.getNumInChannels());
            console.log("Pd: audio output channels: " + pd.getNumOutChannels());
            console.log("Pd: audio sample rate: " + pd.getSampleRate());
            console.log("Pd: audio ticks per buffer: " + pd.getTicksPerBuffer());
          }
          else {
            // failed to reinit pd
            console.error("Pd: failed to reinitialize pd");
            Module.mainExit();
          }
        }

        // open midi (called by "pd midi-dialog" message)
        // receives input/output arrays of only selected devices
        // 0: first available device, 1: second available device...
        Module.Pd.openMidi = function (midiinarr, midioutarr) {
          if (!isWebMidiSupported)
            return;

          // if the selected device doesn't exist, use first available device instead
          midiinarr = midiinarr.map(item => item >= WebMidi.inputs.length || item < 0 ? 0 : item);
          midioutarr = midioutarr.map(item => item >= WebMidi.outputs.length || item < 0 ? 0 : item);

          // save this settings so we can check again later when connection status changes 
          midiarr = [];
          for (var i = 0; i < 10; i++) {
            var devno = i < midiinarr.length ? midiinarr[i] + 1 : 0;
            midiarr.push(devno);
          }
          for (var i = 0; i < 10; i++) {
            var devno = i < midioutarr.length ? midioutarr[i] + 1 : 0;
            midiarr.push(devno);
          }
          // remove duplicates and convert device numbers to ids
          midiinarr = Array.from(new Set(midiinarr));
          midioutarr = Array.from(new Set(midioutarr));
          midiInIds = midiinarr.map(item => WebMidi.inputs[item].id);
          midiOutIds = midioutarr.map(item => WebMidi.outputs[item].id);

          // print all selected devices to the console
          for (var i = 0; i < midiInIds.length; i++) {
            var input = WebMidi.getInputById(midiInIds[i]);
            console.log("Midi: input" + (i + 1) + ": " + input.name);
          }
          for (var i = 0; i < midiOutIds.length; i++) {
            var output = WebMidi.getOutputById(midiOutIds[i]);
            console.log("Midi: output" + (i + 1) + ": " + output.name);
          }
          // receive midi messages from WebMidi and forward them to pd input
          function receiveNoteOn(e) {
            pd.sendNoteOn(e.channel, e.note.number, e.rawVelocity);
          }

          function receiveNoteOff(e) {
            pd.sendNoteOn(e.channel, e.note.number, 0);
          }

          function receiveControlChange(e) {
            pd.sendControlChange(e.channel, e.controller.number, e.value);
          }

          function receiveProgramChange(e) {
            pd.sendProgramChange(e.channel, e.value + 1);
          }

          function receivePitchBend(e) {
            // [bendin] takes 0 - 16383 while [bendout] returns -8192 - 8192
            pd.sendPitchBend(e.channel, e.value * 8192 + 8192);
          }

          function receiveAftertouch(e) {
            pd.sendAftertouch(e.channel, e.value * 127);
          }

          function receivePolyAftertouch(e) {
            pd.sendPolyAftertouch(e.channel, e.note.number, e.value * 127);
          }

          for (var i = 0; i < midiInIds.length; i++) {
            var input = WebMidi.getInputById(midiInIds[i]);
            if (input) {
              input.removeListener(); // remove all added listeners
              input.addListener("noteon", "all", receiveNoteOn);
              input.addListener("noteoff", "all", receiveNoteOff);
              input.addListener("controlchange", "all", receiveControlChange);
              input.addListener("programchange", "all", receiveProgramChange);
              input.addListener("pitchbend", "all", receivePitchBend);
              input.addListener("channelaftertouch", "all", receiveAftertouch);
              input.addListener("keyaftertouch", "all", receivePolyAftertouch);
            }
          }
        }

        // get midi in device name
        Module.Pd.getMidiInDeviceName = function (devno) {
          if (!isWebMidiSupported)
            return;
          if (devno >= WebMidi.inputs.length || devno < 0) {
            devno = 0;
          }
          var name = WebMidi.inputs[devno].name;
          var lengthBytes = lengthBytesUTF8(name) + 1;
          var stringOnWasmHeap = _malloc(lengthBytes);
          stringToUTF8(name, stringOnWasmHeap, lengthBytes);
          return stringOnWasmHeap;
        }

        // get midi out device name
        Module.Pd.getMidiOutDeviceName = function (devno) {
          if (!isWebMidiSupported)
            return;
          if (devno >= WebMidi.inputs.length || devno < 0) {
            devno = 0;
          }
          var name = WebMidi.outputs[devno].name;
          var lengthBytes = lengthBytesUTF8(name) + 1;
          var stringOnWasmHeap = _malloc(lengthBytes);
          stringToUTF8(name, stringOnWasmHeap, lengthBytes);
          return stringOnWasmHeap;
        }

        // receive gui commands (only called in gui mode)
        Module.Pd.receiveCommandBuffer = function (data) {
          var command_buffer = {
            next_command: ""
          };
          perfect_parser(data, command_buffer);
        }

        // receive print messages (only called in no gui mode)
        Module.Pd.receivePrint = function (s) {
          console.log(s);
        }

        // receive from pd's subscribed sources
        Module.Pd.receiveBang = function (source) {
        }

        Module.Pd.receiveFloat = function (source, value) {
        }

        Module.Pd.receiveSymbol = function (source, symbol) {
        }

        Module.Pd.receiveList = function (source, list) {
        }

        Module.Pd.receiveMessage = function (source, symbol, list) {
        }

        // receive midi messages from pd and forward them to WebMidi output
        Module.Pd.receiveNoteOn = function (channel, pitch, velocity) {
          for (var i = 0; i < midiOutIds.length; i++) {
            var output = WebMidi.getOutputById(midiOutIds[i]);
            if (output) {
              output.playNote(pitch, channel, { rawVelocity: true, velocity: velocity });
            }
          }
        }

        Module.Pd.receiveControlChange = function (channel, controller, value) {
          for (var i = 0; i < midiOutIds.length; i++) {
            var output = WebMidi.getOutputById(midiOutIds[i]);
            if (output) {
              output.sendControlChange(controller, value, channel);
            }
          }
        }

        Module.Pd.receiveProgramChange = function (channel, value) {
          for (var i = 0; i < midiOutIds.length; i++) {
            var output = WebMidi.getOutputById(midiOutIds[i]);
            if (output) {
              output.sendProgramChange(value, channel);
            }
          }
        }

        Module.Pd.receivePitchBend = function (channel, value) {
          for (var i = 0; i < midiOutIds.length; i++) {
            var output = WebMidi.getOutputById(midiOutIds[i]);
            if (output) {
              // [bendin] takes 0 - 16383 while [bendout] returns -8192 - 8192
              output.sendPitchBend(value / 8192, channel);
            }
          }
        }

        Module.Pd.receiveAftertouch = function (channel, value) {
          for (var i = 0; i < midiOutIds.length; i++) {
            var output = WebMidi.getOutputById(midiOutIds[i]);
            if (output) {
              output.sendChannelAftertouch(value / 127, channel);
            }
          }
        }

        Module.Pd.receivePolyAftertouch = function (channel, pitch, value) {
          for (var i = 0; i < midiOutIds.length; i++) {
            var output = WebMidi.getOutputById(midiOutIds[i]);
            if (output) {
              output.sendKeyAftertouch(pitch, channel, value / 127);
            }
          }
        }

        Module.Pd.receiveMidiByte = function (port, byte) {
        }

        // default audio settings
        var numInChannels = 0; // supported values: 0, 1, 2
        var numOutChannels = 2; // supported values: 1, 2
        var sampleRate = 44100; // might change depending on browser/system
        var ticksPerBuffer = 32; // supported values: 4, 8, 16, 32, 64, 128, 256

        // open audio devices, init pd
        if (pd.init(numInChannels, numOutChannels, sampleRate, ticksPerBuffer)) {

          // print obtained settings
          console.log("Pd: successfully initialized");
          console.log("Pd: audio input channels:", pd.getNumInChannels());
          console.log("Pd: audio output channels:", pd.getNumOutChannels());
          console.log("Pd: audio sample rate:", pd.getSampleRate());
          console.log("Pd: audio ticks per buffer:", pd.getTicksPerBuffer());

          // add internals/externals help/search paths
          var helpPath = "purr-data/doc/5.reference";
          var extPath = "purr-data/extra";
          pd.addToHelpPath(helpPath);
          pd.addToSearchPath(extPath);
          pd.addToHelpPath(extPath);
          var dir = FS.readdir(extPath);
          for (var i = 0; i < dir.length; i++) {
            var item = dir[i];
            if (item.charAt(0) != ".") {
              var path = extPath + "/" + item;
              pd.addToSearchPath(path); // externals can be created without path prefix
              pd.addToHelpPath(path);
            }
          }
        }
        else { // failed to init pd
          console.error("Pd: failed to initialize pd");
          Module.mainExit();
        }
      }
      , mainLoop: function () { // called every frame (use for whatever)
      }
      , mainExit: function () { // this won't be called from emscripten
        console.error("quiting emscripten...");
        if (typeof Module.pd == "object") {
          Module.pd.clear(); // clear pd, close audio devices
          Module.pd.unsubscribeAll(); // unsubscribe all subscribed sources
          Module.pd.delete(); // quit SDL, emscripten
        }
        if (typeof WebMidi == "object") {
          WebMidi.disable(); // disable all midi devices
        }
      }
    };



    //--------------------- pdgui.js ----------------------------
    function pdsend() {
      console.error("pdsend called, which should have been replaced");
    }

    function gui_ping() {
      pdsend("pd ping");
    }

    function gui_post(string, type) {
      console.log("gui_post", string, type);
    }

    function gui_post_error(objectid, loglevel, error_msg) {
      console.log("gui_post_error", objectid, loglevel, error_msg);
    }

    function gui_print(object_id, selector, array_of_strings) {
      console.log("gui_print", object_id, selector, array_of_strings);
    }

    function gui_legacy_tcl_command(file, line_number, text) {
      console.log("gui_legacy_tcl_command", file, line_number, text);
    }

    function gui_load_default_image(dummy_cid, key) {
      console.log("gui_load_default_image", dummy_cid, key);
    }

    function gui_undo_menu(cid, undo_text, redo_text) {
      console.log("gui_undo_menu", cid, undo_text, redo_text);
    }

    function gui_startup(version, fontname_from_pd, fontweight_from_pd, apilist, midiapilist) {
      console.log("gui_startup", version, fontname_from_pd, fontweight_from_pd, apilist, midiapilist);
    }

    function gui_set_cwd(dummy, cwd) {
      console.log("gui_set_cwd", dummy, cwd);
    }

    function set_audioapi(val) {
      console.log("set_audioapi", val);
    }

    function gui_pd_dsp(state) {
      console.log("gui_pd_dsp", state);
    }

    function gui_canvas_new(cid, width, height, geometry, zoom, editmode, name, dir, dirty_flag, hide_scroll, hide_menu, cargs) {
      console.log("gui_canvas_new", cid, width, height, geometry, zoom, editmode, name, dir, dirty_flag, hide_scroll, hide_menu, cargs);
    }

    function gui_set_toplevel_window_list(dummy, attr_array) {
      console.log("gui_pd_dsp", dummy, attr_array);
    }

    function gui_window_close(cid) {
      console.log("gui_window_close", cid);
    }

    function gui_canvas_get_scroll(cid) {
      console.log("gui_canvas_get_scroll", cid);
    }

    function perfect_parser(data, cbuf, sel_array) {
      var i, len, selector, args;
      len = data.length;
      for (i = 0; i < len; i++) {
        // check for end of command:
        if (data[i] === 31) { // unit separator
          // decode next_command
          try {
            // This should work for all utf-8 content
            cbuf.next_command =
              decodeURIComponent(cbuf.next_command);
          }
          catch (err) {
            // This should work for ISO-8859-1
            cbuf.next_command = unescape(cbuf.next_command);
          }
          // Turn newlines into backslash + "n" so
          // eval will do the right thing with them
          cbuf.next_command = cbuf.next_command.replace(/\n/g, "\\n");
          cbuf.next_command = cbuf.next_command.replace(/\r/g, "\\r");
          selector = cbuf.next_command.slice(0, cbuf.next_command.indexOf(" "));
          args = cbuf.next_command.slice(selector.length + 1);
          cbuf.next_command = "";
          // Now evaluate it
          //post("Evaling: " + selector + "(" + args + ");");
          // For communicating with a secondary instance, we filter
          // incoming messages. A better approach would be to make
          // sure that the Pd engine only sends the gui_set_cwd message
          // before "gui_startup".  Then we could just check the
          // Pd engine id in "gui_startup" and branch there, instead of
          // fudging with the parser here.
          if (!sel_array || sel_array.indexOf(selector) !== -1) {
            eval(selector + "(" + args + ");");
          }
        } else {
          cbuf.next_command += "%" +
            ("0" // leading zero (for rare case of single digit)
              + data[i].toString(16)) // to hex
              .slice(-2); // remove extra leading zero
        }
      }
    }


    //--------------------- for testing patch handling ----------------------------
    var currentFile = ""; // current file to handle, just for testing, should be deleted later

    function uploadPatch() {
      var files = this.files;
      if (files.length === 0) {
        console.log("No file is selected");
        return;
      }
      var file = files[0];
      var reader = new FileReader();
      reader.onload = function () {
        var uint8Array = new Uint8Array(reader.result);
        FS.createDataFile("/", file.name, uint8Array, true, true, true);
        currentFile = file.name;
      };
      reader.readAsArrayBuffer(file);
    }

    function newPatch() {
      var filename = "Untitiled-1.pd";
      var content = "#N canvas 0 0 450 300 10;";
      var uint8Array = new TextEncoder().encode(content);
      FS.createDataFile("/", filename, uint8Array, true, true, true);
      currentFile = filename;
    }

    function openPatch() {
      if (currentFile === "") return;
      Module.pd.openPatch(currentFile, "/");
    }

    function closePatch() {
      if (currentFile === "") return;
      Module.pd.closePatch(currentFile);
    }

    function printPatch() {
      if (currentFile === "") return;
      var uint8Array = FS.readFile(currentFile);
      var content = new TextDecoder("utf-8").decode(uint8Array);
      console.log(content);
    }

    function downloadPatch() {
      if (currentFile === "") return;
      var uint8Array = FS.readFile(currentFile);
      var a = document.createElement('a');
      a.download = currentFile;
      var blob = new Blob(
        [uint8Array],
        {
          type: "text/plain;charset=utf-8"
        }
      );
      a.href = URL.createObjectURL(blob);
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      }, 2000);
    }

    function dspOn() {
      pdsend("pd dsp 1");
    }

    function dspOff() {
      pdsend("pd dsp 0");
    }

    function gui_audio_properties(gfxstub, sys_indevs, sys_outdevs,
      pd_indevs, pd_inchans, pd_outdevs, pd_outchans, audio_attrs) {
      console.log("gui_audio_properties", gfxstub, sys_indevs, sys_outdevs,
        pd_indevs, pd_inchans, pd_outdevs, pd_outchans, audio_attrs);
    }

    function gui_midi_properties(gfxstub, sys_indevs, sys_outdevs,
      pd_indevs, pd_outdevs, midi_attrs) {
      console.log("gui_midi_properties", gfxstub, sys_indevs, sys_outdevs,
        pd_indevs, pd_outdevs, midi_attrs);
    }

    function set_midiapi(val) {
      console.log("set_midiapi", val);
    }

    window.onload = async () => {
      document.getElementById("uploadPatch").addEventListener("change", uploadPatch, false);
      document.getElementById("newPatch").addEventListener("click", newPatch, false);
      document.getElementById("openPatch").addEventListener("click", openPatch, false);
      document.getElementById("closePatch").addEventListener("click", closePatch, false);
      document.getElementById("printPatch").addEventListener("click", printPatch, false);
      document.getElementById("downloadPatch").addEventListener("click", downloadPatch, false);
      document.getElementById("dspOn").addEventListener("click", dspOn, false);
      document.getElementById("dspOff").addEventListener("click", dspOff, false);
    };
  </script>
  <script async src="main.js"></script>
</body>

</html>